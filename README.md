# genetic
genetic code c++
#include <iostream>
#include <Windows.h>
#include <ctime>

 
void Houseshow(const HWND& hwnd, const HDC& dc, const int x, const int y, int a) {				//функция вывода пикселей на экран
	HBRUSH brush; //Переменная brush - это кисть, она будет использоваться для закрашивания		//
	if (a==0) brush = CreateHatchBrush(7, RGB(255, 255, 255));									//
	if (a==1) brush = CreateHatchBrush(7, RGB(0, 0, 255));										//
	SelectObject(dc, brush);																	//
	Rectangle(dc, x,y,  x+30,  y+30);															//
	DeleteObject(brush);																		//
}																								//

int main() {
	for (int b=0;b<10;){       //повторяю

	srand(time(NULL));      //связывает rand() с текущим временем
	//int population[5][5][100],					//хранит матрицы начального поколения
		//newpopulation[5][5][100],				//				 нового поколения
		int population[20][20][100],newpopulation[20][20][100],result[20][20]={{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0}
																	,{0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0}
																	,{0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0}
																	,{0,0,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,1,0}
																	,{0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1}
																	
																	,{0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1}
																	,{0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1}
																	,{0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1}
																	,{0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1}
																	,{0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1}

																	,{1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1}
																	,{0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
																	,{0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0}
																	,{1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,0,0}
																	,{0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0}

																	,{0,0,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,1,0,0}
																	,{0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,1,1,0}
																	,{0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0}
																	,{0,1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0}
																	,{0,0,1,1,1,0,0,0,0,1,1,1,1,1,0,1,1,0,0,0}};
	int t(0),i(0);			//переменная і для кол-ва прохода цикла, t для хранения номера лучшей матрицы, чтоб потом вывести её на экран

	int 
		same2[100],	//хранит номера матриц для скрещивания
		same3[100],	//хранит числа на сколько похожа каждая матрица на результат
		z(0),		//число схожести
		p(0),		//для завершения цикла
		z1(0);		//для повторной селекции

	HWND hwnd = GetConsoleWindow(); //Берём ориентир на консольное окно (В нём будем рисовать)
	HDC dc = GetDC(hwnd); //Цепляемся к консольному окну
	RECT window = {}; //Переменная window будет использована для получения ширины и высоты окна

	for (int m=0;m<100;m++)						//обнуляю значения всех матриц нового поколения
	{
			for (int f=0; f<20;f++)       //делаю матрицу
			{
				for (int g=0;g<20;g++)
				{	
					newpopulation[g][f][m]=0;
				};
		};
	};
	for (int m=0;m<100;m++)					//делаю матрицы начального поколения
	{
			for (int f=0; f<20;f++)       //делаю матрицу
			{
				for (int g=0;g<20;g++)
				{	
					population[g][f][m]=rand()%2;
				};
		};
	};

	for (i=0;i>-1;i++)                              //начало алгоритма
	{
		
		Sleep(10);
		int maximum=0,	//для определения лучшей матрицы
			same4[100];	//для хранения номеров матриц
		
		for (int m=0;m<100;m++)			//числа от 0 до кол-ва матриц
			same4[m]=m;

		if (rand()%2==0) for (int f=0; f<20;f++)       //мутация
			{
				for (int g=0;g<20;g++)
				{	
					population[g][f][rand()%100]=rand()%2;
				};
			};

		//селекция
	
		for (int m=0;m<100;m++)                  //на сколько матрица похожа на результат
	{             
		z=0;														                               //
			for (int f=0; f<20;f++)                                      //             
			{														                                 //      
				for (int g=0;g<20;g++){                                    //
																	                                 //
					if (population[g][f][m]==result[g][f]) z+=1;             //за каждый схожий с конечной матрицой 
																	                                 //пиксель значение z увеличивается на 1
				};                                                         //                       
																	                                 //
			};													                                 //			
			same3[m]=z;												                           //значение схожести каждой матрицы в массив    						          	
			if(maximum<z) {maximum=z;t=m;};							                 //нахождение номера наиболее схожей матрицы
			if (z==400) {t=m;p=1;break;};                                //  если матрица полностью похожа, то р=1     
				                                                           //
	};                                                               //             
	
		if (p==1) break;											                         //если р=1 конец цикла							
	
	int temp(0);		// временная переменная для хранения значения элемента сортируемого массива
	
																	              //сортирую 
	for(int m=0;m<100-1; m++)										  //массив 						
	{																              //по убыванию			
		for (int u=0;u<100-m-1;u++)									//																
		{															              //			
			if (same3[u]<same3[u+1]) {								//массив с номерами матриц также меняется			
				temp=same3[u];													//как и сортировка массива схожести				
				same3[u]=same3[u+1];								    //
				same3[u+1]=temp;									      //
				temp=same4[u];										      //				
				same4[u]=same4[u+1];								    //									
				same4[u+1]=temp;									      //																													
			}														              //
		}															              //
	}
		

																	  //создаю массив same2 
																	  //с номерами матриц
			for (int m=0; m<100;m++)								  //которые буду скрещивать   
			{														  //       
				same2[m]=same4[rand()%50];							  //выбирается случайная из 50 матриц          
																	  //массива          
			};														  //                              
	  
			//скрещивание

			for (int m=0;m<100;m++)
			{
				int l,ll,lll;
				l=same2[m+1];
				if (m==99) l=same2[0];
				ll=rand()%5;
				lll=rand()%5;
				for(int f=0;f<20;f++)
				{
					for(int g=0;g<20;g++)
					{
						if ((ll<=f)&&(lll<=g)) newpopulation[g][f][m]=population[g][f][same2[m]];
						if ((ll>f)&&(lll>g)) newpopulation[g][f][m]=population[g][f][l];
					};
				};
			};

				//повторная селекция
	for (int m=0;m<100;m++)			//сравниваю схожести нового и старого поколений
	{	z=0;
		z1=0;
		for (int f=0;f<20;f++)
		{
			for(int g=0;g<20;g++)
				{
					if (population[g][f][m]==result[g][f]) z+=1;
					if (newpopulation[g][f][m]==result[g][f]) z1+=1;
				};
		};													//если новое поколение более схоже, то оно заменяет старое
		for (int f=0;f<20;f++)
		{													//формирую новое поколение 
			for(int g=0;g<20;g++)
			{
				if (z1>z) population[g][f][m]=newpopulation[g][f][m];
			};
		};
	};


//вывод матрицы на экран	
for (int f=0; f<20;f++)        //вывожу матрицу
	{
		for (int g=0;g<20;g++)
			Houseshow(hwnd,dc,100+f*30,g*30,population[g][f][t]);
	};

	};
	
	for (int f=0; f<20;f++)        //вывожу матрицу
	{
		for (int g=0;g<20;g++)
		Houseshow(hwnd,dc,100+f*30,g*30,population[g][f][t]);
	};
	std::cout<<i<<" "; //вывожу кол-во итераций цикла
	std::cin.get(); //ждёт команды для продолжения выполнения действия
	
	};

	};
	
